<!doctype html><html><head><meta http-equiv=x-ua-compatible content="ie=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Who"><meta name=keywords content="theme,kagome"><meta name=generator content="Hugo 0.103.0"><title>php-garbage-collection 🌟 分24期买泡面🍜</title><meta property="og:title" content="php-garbage-collection"><meta property="og:description" content="Explains Garbage Collection (also known as GC) of PHP PHP Language PHP 是脚本语言，所谓脚本语言，就是说PHP并不是独立运行的，要运行PHP代码需要PHP解析器，用户编写的PHP代码最终都"><meta property="og:type" content="article"><meta property="og:url" content="https://onlw.github.io/posts/201812090000/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-12-09T00:00:00+00:00"><meta property="article:modified_time" content="2018-12-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="php-garbage-collection"><meta name=twitter:description content="Explains Garbage Collection (also known as GC) of PHP PHP Language PHP 是脚本语言，所谓脚本语言，就是说PHP并不是独立运行的，要运行PHP代码需要PHP解析器，用户编写的PHP代码最终都"><link rel=stylesheet href=https://onlw.github.io/assets/css/style.min.699f46622e3574a7f9ecca4c5877067845fe89ffcd9c4335df2dff23ddae215e.css integrity="sha256-aZ9GYi41dKf57MpMWHcGeEX+if/NnEM13y3/I92uIV4="><script src=https://onlw.github.io/assets/js/main.min.182da266209851bc7c828aa7377f98f914e1e76c8decdd53a6cbe9bffea92cde.js integrity="sha256-GC2iZiCYUbx8goqnN3+Y+RTh52yN7N1Tpsvpv/6pLN4="></script></head><body><header class="header-container layout-block layout-padding"><div class="header-inner content-padding-large soft-size--large soft-style--box"><div class=header-logo><a href=https://onlw.github.io/><h1>分24期买泡面🍜</h1></a></div><nav class=header-nav><div class=header-nav--btn><div class=btn-item></div><div class=btn-item></div><div class=btn-item></div></div><div class=header-nav--list><div><a class="list-item soft-size--small soft-style--hover soft-style--active" href=/ title>HOME</a>
<a class="list-item soft-size--small soft-style--hover soft-style--active" href=/posts title>POSTS</a>
<a class="list-item soft-size--small soft-style--hover soft-style--active" href=/message title>MESSAGE</a>
<a class="list-item soft-size--small soft-style--hover soft-style--active" href=/link title>LINK</a></div></div></nav></div></header><main id=content><div class="single-container layout-block"><div class=article-info><div class="article-header layout-padding"><div class="article-cover card-container content-padding-large soft-size--large soft-style--box"><div class=card-cover></div><div class=card-text><h1 class=card-text--title>php-garbage-collection</h1><p class=card-text--row>2018-12-09 00:00</p><ul class=card-text--tag><li><a href=https://onlw.github.io/categories/program/>program</a></li></ul><ul class=card-text--tag><li><a href=https://onlw.github.io/tags/php/>php</a></li></ul></div></div></div><div class=article-content><div class="markdown-body content-padding-large soft-size--large soft-style--box"><h2 id=explains-garbage-collection-also-known-as-gc-of-php>Explains Garbage Collection (also known as GC) of PHP</h2><h3 id=php-language>PHP Language</h3><p>PHP 是脚本语言，所谓脚本语言，就是说PHP并不是独立运行的，要运行PHP代码需要PHP解析器，用户编写的PHP代码最终都会被PHP解析器解析执行，PHP的执行是通过 <code>Zend engine</code>（ZE, Zend引擎），ZE是用C编写的，用户编写的PHP代码最终都会被翻译成PHP的虚拟机ZE的虚拟指令（<code>OPCODES</code>）来执行，也就说最终会被翻译成一条条的指令</p><h3 id=概念>概念</h3><ul><li><p>Garbage Collection : GC</p></li><li><p>PHP 5.2以前, PHP使用引用计数(Reference counting)来做资源管理，PHP 5.3才引入GC</p></li><li><p>zval ：所有的变量都是用一个结构 zval 结构来保存的</p><ul><li>value : 值，是真正保存数据的关键部分，定义为一个联合体(union)</li><li>type : 储存变量的类型</li><li>is_ref ：被 & 引用的数量</li><li>refcount ：引用计数，记录了当前的 zval 被引用的次数（这里的引用并不是真正的 & ，而是有几个变量指向它）</li></ul></li><li><p>Copy On Write</p></li><li><p>Change On Write</p></li><li><p>过程</p><p>PHP5.2 : <a href=http://php.net/manual/en/features.gc.refcounting-basics.php target=_blank rel=noopener>Reference Counting</a> : 引用计数，GC根本算法</p><p>PHP5.3 : <a href=http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf target=_blank rel=noopener>Concurrent Cycle Collection in Reference Counted Systems</a></p></li><li><p>function : <a href=http://php.net/manual/en/function.memory-get-usage.php target=_blank rel=noopener>memory_get_usage</a></p></li><li><p>function : xdebug_debug_zval() : 需要安装xdebug</p></li><li><p>function : <a href=http://php.net/manual/en/function.debug-zval-dump.php target=_blank rel=noopener>debug_zval_dump</a> 当不使用xdebug时，可以作为替代xdebug_debug_zval 的方法</p></li></ul><h3 id=introdution>Introdution</h3><ul><li><p><code>zval</code></p><p>声明一个变量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$addr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;i value&#39;</span>;
</span></span></code></pre></div><p>PHP内部都是使用 zval 来表示变量的，那对于上面的脚本，ZE是如何把 <code>$addr</code> 变量 和内部的 zval 结构联系起来的呢？变量都是有名字的（本例中变量名为 <code>$addr</code> ），而 zval 中并没有相应的字段来体现变量名。PHP内部有一个机制，来实现变量名到 zval 的映射，在PHP中，所有的变量都会存储在一个 <code>hash table</code>中，当你创建一个变量的时候，PHP会为这个变量分配一个 zval，填入相应的信息，然后将这个变量的名字和指向这个 zval 的指针填入一个数组中。当你获取这个变量的时候，PHP会通过查找 hash table，取得对应的 zval</p><p><code>注意：数组和对象这类复合类型在生成zval时，会为每个单元生成一个 zval</code></p><p><p><img src=https://image-static.segmentfault.com/101/144/1011448460-569f6db18305e_articlex alt loading=lazy></p></p></li><li><p><code>释放内存</code></p><p>我们经常说每个变量都有一个内存地址，那这个 zval 和变量的内存地址，这俩有什么关系吗？定义一个变量会开辟一块内存，这块内存好比一个盒子，盒子里放了zval，zval里保存了变量的相关信息，需要开辟多大的内存，是由zval所占空间大小决定的，zval是内存对象，垃圾回收的时候会把zval和内存地址（盒子）分别释放掉</p></li><li><p><code>refcount is_ref</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;string&#39;</span>;
</span></span><span style=display:flex><span>$b <span style=color:#f92672>=</span> $a;
</span></span><span style=display:flex><span><span style=color:#a6e22e>unset</span>($a);
</span></span></code></pre></div><p>第一行代码创建变量 a ,申请了 6 字节内存，</p><p>第二行代码定义了变量 b, 将 a 的值赋予 b</p><p>第三行代码释放了变量 a</p><p>如果对于每一个变量重新分配内存，那么变量 a b要申请 12 字节的内存，并且变量 a,还是个无用的数据（被unset了），那么有没有什么方法节省这块资源呢？将变量 a b对应的指针指向同一个 zval 即可</p><p><code>refcount</code></p><p>refcount 指的是变量被引用的次数（reference count ?）,这里的引用并不是真正的 & ，而是有几个变量指向它</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>$b <span style=color:#f92672>=</span> $a;
</span></span></code></pre></div><p>第一行，创建了一个变量 a，变量值是 1。 此时保存int 1 的这个 zval 的 refcount 为 1
第二行，创建了一个新的整形变量（通过赋值的方式），变量也指向刚才创建的 zval，并将这个 zval 的 refcount 加1，此时这个 zval 的 refcount 为2
所以，这个时候（通过值传递的方式赋值给别的变量），并没有产生新的 zval，两个变量指向同一 zval，通过一个计数器来共用 zval 及内存地址，以达到节省内存空间的目的
<code>当一个变量被第一次创建的时候，它对应的 zval 结构的 refcount 的值会被初始化为 1</code>，因为只有这一个变量在用它。但是当你把这个变量赋值给别的变量时，refcount 属性便会 加1 变成 2，因为现在有两个变量在用这个 zval 结构了</p></li><li><p><code>debug_zval_dump</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>debug_zval_dump</span>($a);
</span></span><span style=display:flex><span>$b <span style=color:#f92672>=</span> $a;
</span></span><span style=display:flex><span><span style=color:#a6e22e>debug_zval_dump</span>($a);
</span></span></code></pre></div><p>输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#a6e22e>long</span>(<span style=color:#ae81ff>1</span>) <span style=color:#a6e22e>refcount</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>long</span>(<span style=color:#ae81ff>1</span>) <span style=color:#a6e22e>refcount</span>(<span style=color:#ae81ff>3</span>)
</span></span></code></pre></div><p>如果你奇怪 ，<code>var的refcount应该是1</code>啊？
我们知道，对于简单变量，PHP是以传值的形式传参数的。也就是说，当执行debug_zval_dump($var)的时候，var会以传值的方式传递给debug_zval_dump，也就是会导致var的refcount加1，所以只要能看到，当变量赋值给一个变量以后，能导致zval的refcount加 1</p><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>$b <span style=color:#f92672>=</span> $a;
</span></span><span style=display:flex><span>$c <span style=color:#f92672>=</span> $b;
</span></span><span style=display:flex><span>$d <span style=color:#f92672>=</span> $a;
</span></span><span style=display:flex><span><span style=color:#75715e># long(1) refcount(5)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>debug_zval_dump</span>($a);
</span></span></code></pre></div></li><li><p><code>unset</code></p><p>当 unset(var) 的时候，它删除符号表里的var的信息，准备清理它对应的zval及内存空间，这时它发现var对应的zval结构的 refcount 值是 > 1，也就是说，还有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了</p><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>$b <span style=color:#f92672>=</span> $a;
</span></span><span style=display:flex><span><span style=color:#a6e22e>unset</span>($a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># long(1) refcount(2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>debug_zval_dump</span>($b);
</span></span></code></pre></div></li><li><p><code>Copy On Write</code></p><p>写入时复制是指：在 用变量对变量进行赋值时，这些相同值的变量指向同一块内存，只有当这些指向同一块内存的 相同值的变量 中的某一个变量的值 <code>发生改变</code>的时候，才需要进行<code>变量分离</code>，即：将 值发生改变的变量分离出来</p><p>使用场景：变量的多次赋值；函数的参数传递。</p><p>PHP中，Zend引擎为了区分同一块内存是否被多个变量引用，在zval结构中定义了ref_count和is_ref两个变量。</p><p><strong>ref_count定义了内存被变量引用的次数，次数为0时销毁</strong></p><p><strong>is_ref定义了变量是否被强制引用，被强制引用时，值为1</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>$b <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>$a;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$a <span style=color:#a6e22e>的</span> <span style=color:#a6e22e>is_ref</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>$b <span style=color:#f92672>=</span> $a;
</span></span><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># long(2) refcount(2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>debug_zval_dump</span>($a);
</span></span><span style=display:flex><span><span style=color:#75715e># long(1) refcount(2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>debug_zval_dump</span>($b);
</span></span></code></pre></div><p>PHP在修改一个变量以前，会首先查看这个变量的refcount，如果refcount大于1，PHP就会执行一个分离的过程（在Zend引擎中，分离是破坏一个引用对的过程）对于上面的代码，当执行到第三行的时候，PHP发现var想要改变，并且它指向的zval的refcount大于1，那么PHP就会复制一个新的zval出来，改变其值，将改变的变量指向新的zval（，并将原zval的refcount减1，并修改symbol_table里该变量的指针，使得 a 和 b 分离(Separation)。这个机制就是所谓的copy on write（写时复制，这里的写包括普通变量的修改及数组对象里的增加、删除单元操作）</p></li><li><p><code>Change On Write</code></p><p>使用变量复制的时候 ，PHP内部并不是真正的复制，而是采用指向相同的zval结构来节约开销。那么，对于PHP中的引用，又是如何实现呢</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>$reference <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>$a;
</span></span><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># refcount(2)  is_ref(1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>xdebug_debug_zval</span>( <span style=color:#e6db74>&#39;a&#39;</span> );
</span></span></code></pre></div><p>代码运行结果，$a 会被改为 2, 这个过程叫做 <code>change on write</code>, ZE 如何得知是否采用 Separation ？这个需要用到</p><p>$a 的 is_ref属性，它代表是否被 & 引用，变量的 is_ref 默认为 0 ，大于 0则表示被引用，当 is_ref > 0 或者 refcount = 1,此时不需要 Separation，而是直接修改 zval 的值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>if</span>($if_ref <span style=color:#f92672>||</span> $refcount <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>    <span style=color:#75715e># alter zval instead of Separation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>尽管已经存在写时复制和写时改变，但仍然还存在一些不能通过is_ref和refcount来解决的问题</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$var <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>$var_dup <span style=color:#f92672>=</span> $a;
</span></span><span style=display:flex><span>$var_ref <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>$var;
</span></span></code></pre></div><p>当执行第二行代码的时候,变量的值必须分离成两份完全独立的存在，也就是说php将一个zval的isref从0设为1之前，当然此时refcount还没有增加，会看该zval的refcount，如果refcount>1，则会分离, 将var_dup分离出去，并将var和var_ref做change on write关联。也就是，refcount=2, is_ref=1.
所以内存会给变量var_dup 分配出一个新的zval，类型与值同 var和var_ref指向的zval一样，是新分配出来的，尽管他们拥有同样的值，但是必须通过两个zval来实现。试想一下，如果三者指向同一个zval的话，改变 <code>$vardup</code>的值，那么var和 var_ref 也会受到影响，这样是错误的</p><p><p><img src=https://image-static.segmentfault.com/238/459/2384596612-569f6e23462c4_articlex alt loading=lazy></p></p><p>类似的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>$b <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>$a;
</span></span><span style=display:flex><span>$c <span style=color:#f92672>=</span> $a;
</span></span></code></pre></div><p><p><img src=https://image-static.segmentfault.com/113/070/113070557-569f6e35da911_articlex alt loading=lazy></p></p></li><li><p><code>debug_zval_dump 参数是引用的话，refcount永远为1</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>$b <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>$a;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># long(1) refcount(1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>debug_zval_dump</span>($a);
</span></span></code></pre></div><p>PHP先看变量指向的zval是否被引用，如果是引用，则不再产生新的zval
甭管哪个变量引用了它，比如有个变量a被引用了，b=&a，就算自己引用自己a=&a，a所指向的zval都不会被复制，改变其中一个变量的值，另一个值也被改变（change on write）
如果is_ref为0且refcount大于1，改变其中一个变量时，复制新的zval（copy on write）</p></li></ul><h3 id=reference-counting>Reference Counting</h3><p>PHP5.2中使用的内存回收算法是<a href=http://en.wikipedia.org/wiki/Reference_counting target=_blank rel=noopener>Reference Counting</a>，中文叫做“引用计数”，其思想非常直观和简洁：为每个内存对象分配一个计数器，当一个内存对象建立时计数器初始化为1（因此此时总是有一个变量引用此对象），以后每有一个新变量引用此内存对象，则计数器加1，而每当减少一个引用此内存对象的变量则计数器减1，当垃圾回收机制运作的时候，将所有计数器为0的内存对象销毁并回收其占用的内存。而PHP中内存对象就是zval，而计数器就是refcount。</p><p>Important : <a href=http://php.net/manual/en/features.gc.refcounting-basics.php target=_blank rel=noopener>Reference Counting Basics</a></p><p>出现的问题 ： 引用的值为变量自身，内存泄漏 -> <a href=http://php.net/manual/en/features.gc.refcounting-basics.php target=_blank rel=noopener>泄露实例</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$a <span style=color:#f92672>=</span> <span style=color:#66d9ef>array</span>( <span style=color:#e6db74>&#39;one&#39;</span> );
</span></span><span style=display:flex><span>$a[] <span style=color:#f92672>=&amp;</span> $a;
</span></span><span style=display:flex><span><span style=color:#a6e22e>xdebug_debug_zval</span>( <span style=color:#e6db74>&#39;a&#39;</span> );
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 类似如下</span>
</span></span><span style=display:flex><span>a: <span style=color:#f92672>(</span>refcount<span style=color:#f92672>=</span>2, is_ref<span style=color:#f92672>=</span>1<span style=color:#f92672>)=</span>array <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>   0 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>(</span>refcount<span style=color:#f92672>=</span>1, is_ref<span style=color:#f92672>=</span>0<span style=color:#f92672>)=</span><span style=color:#e6db74>&#39;one&#39;</span>,
</span></span><span style=display:flex><span>   1 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>(</span>refcount<span style=color:#f92672>=</span>2, is_ref<span style=color:#f92672>=</span>1<span style=color:#f92672>)=</span>...
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>图示：</p><p><p><img src=http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-loop-array.png alt loading=lazy></p></p><p>能看到数组变量 (a) 同时也是这个数组的第二个元素(1) 指向的变量容器中“refcount”为 <em>2</em>。上面的输出结果中的"&mldr;&ldquo;说明发生了递归操作, 显然在这种情况下意味着&rdquo;&mldr;&ldquo;指向原始数组。</p><p>跟刚刚一样，对一个变量调用unset，将删除这个符号，且它指向的变量容器中的引用次数也减1。所以，如果我们在执行完上面的代码后，对变量 a 调用unset, 那么变量 $a 和数组元素 &ldquo;1&rdquo; 所指向的变量容器的引用次数减1, 从"2"变成"1&rdquo;. 下例可以说明:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#a6e22e>unset</span>($a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xdebug_debug_zval</span>( <span style=color:#e6db74>&#39;a&#39;</span> );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>refcount</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>is_ref</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>=</span><span style=color:#66d9ef>array</span> (
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#a6e22e>refcount</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>is_ref</span><span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;one&#39;</span>,
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#a6e22e>refcount</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>is_ref</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>=...</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p><p><img src=http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-leak-array.png alt loading=lazy></p></p><h3 id=清理变量容器的问题cleanup-problems>清理变量容器的问题(Cleanup Problems)</h3><p>尽管不再有某个作用域中的任何符号指向这个结构(就是变量容器)，由于数组元素“1”仍然指向数组本身，所以这个容器不能被清除 。因为没有另外的符号指向它，用户没有办法清除这个结构，结果就会导致<code>内存泄漏</code>。庆幸的是，php将在脚本执行结束时清除这个数据结构，但是在php清除之前，将耗费不少内存。如果你要实现分析算法，或者要做其他像一个子元素指向它的父元素这样的事情，这种情况就会经常发生。当然，同样的情况也会发生在对象上，实际上对象更有可能出现这种情况，因为对象总是隐式的被引用。</p><p>如果上面的情况发生仅仅一两次倒没什么，但是如果出现几千次，甚至几十万次的内存泄漏，这显然是个大问题。这样的问题往往发生在长时间运行的脚本中，比如请求基本上不会结束的守护进程(deamons)或者单元测试中的大的套件(sets)中。后者的例子：在给巨大的eZ(一个知名的PHP Library) 组件库的模板组件做单元测试时，就可能会出现问题。有时测试可能需要耗用2GB的内存，而测试服务器很可能没有这么大的内存。</p><p>###回收周期(Collecting Cycles)</p><p>PHP5.3的垃圾回收算法仍然以引用计数为基础，但是不再是使用简单计数作为回收准则，而是使用了一种同步回收算法，这个算法由IBM的工程师在论文<a href=http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf target=_blank rel=noopener>Concurrent Cycle Collection in Reference Counted Systems</a>中提出。</p><p>首先PHP会分配一个固定大小的“根缓冲区”，这个缓冲区用于存放固定数量的zval，这个数量默认是10,000，如果需要修改则需要修改源代码Zend/zend_gc.c中的常量GC_ROOT_BUFFER_MAX_ENTRIES然后重新编译。</p><p>由上文我们可以知道，一个zval如果有引用，要么被全局符号表中的符号引用，要么被其它表示复杂类型的zval中的符号引用。因此在zval中存在一些可能根（root）。这里我们暂且不讨论PHP是如何发现这些可能根的，这是个很复杂的问题，总之PHP有办法发现这些可能根zval并将它们投入根缓冲区。</p><p>当根缓冲区满额时，PHP就会执行垃圾回收，此回收算法如下：</p><ol><li><p>对每个根缓冲区中的根 zval 按照<code>深度优先遍历算法</code>遍历所有能遍历到的 zval ，并将每个 zval 的 refcount 减1，同时为了避免对同一 zval 多次减1（因为可能不同的根能遍历到同一个 zval ），每次对某个zval减1后就对其标记为“已减”。</p></li><li><p>再次对每个缓冲区中的根 zval 深度优先遍历，如果某个 zval 的 refcount 不为0，则对其加1，否则保持其为0。</p></li><li><p>清空根缓冲区中的所有根（注意是把这些 zval 从缓冲区中清除而不是销毁它们），然后销毁所有 refcount 为0的zval，并收回其内存。</p></li></ol><p>如果不能完全理解也没有关系，只需记住PHP5.3的垃圾回收算法有以下几点特性：</p><ol><li><p>并不是每次 refcount 减少时都进入回收周期，只有根缓冲区满额后在开始垃圾回收。</p></li><li><p>可以解决循环引用问题。</p></li><li><p>可以总将内存泄露保持在一个阈值以下。</p></li></ol><h3 id=php-52-与-php-53-垃圾回收算法的性能比较>PHP 5.2 与 PHP 5.3 垃圾回收算法的性能比较</h3><p><a href=http://php.net/manual/en/features.gc.performance-considerations.php target=_blank rel=noopener>参考 PHP Manual</a></p><h3 id=references>References</h3><ul><li><p><a href=http://php.net/manual/en/features.gc.php target=_blank rel=noopener>PHP Manual GC</a></p></li><li><p><a href=https://segmentfault.com/a/1190000004340427 target=_blank rel=noopener>zval _ 引用计数 _ 变量分离 _ 写时拷贝</a></p></li><li><p><a href=https://segmentfault.com/a/1190000008481434 target=_blank rel=noopener>浅谈PHP5中垃圾回收算法(Garbage Collection)的演化</a></p></li></ul></div></div><div class=article-paging><section class="post-paging--item card-container content-padding-primary soft-size--primary soft-style--box"><div class=card-cover></div><div class=card-text><a href=/posts/201812090000/><h4 class="card-text--title text-ellipsis">mysql-transaction</h4></a><p class=card-text--row>2018-12-09 00:00</p></div></section><section class="post-paging--item card-container content-padding-primary soft-size--primary soft-style--box"><div class=card-cover></div><div class=card-text><a href=/posts/201812080000/><h4 class="card-text--title text-ellipsis">recommended-software-install</h4></a><p class=card-text--row>2018-12-08 00:00</p></div></section></div></div><aside class=widget-info><section class="aside-widget widget-author content-padding-large soft-size--large soft-style--box"><div class=widget-body><div class="author-box avatar"><img class="author-avatar soft-size--round soft-style--box" src="https://s.gravatar.com/avatar/a0570f9d1887caa3f4e5c9df9706d15d?s=200&r=g&d=retro" alt=Who><h2 class="author-name text-ellipsis">Who</h2><p class="author-desc text-ellipsis">人类的悲欢并不相通</p></div></div></section><section class="aside-widget widget-articles content-padding-large soft-size--large soft-style--box"><h2 class=widget-header><div class=title><span>Related Posts</span></div></h2><div class=widget-body><ul class=post-list><li class=post-item><a href=/posts/202209182224/>Clickhouse Start</a></li><li class=post-item><a href=/posts/201910100000/>laravel-throttle</a></li><li class=post-item><a href=/posts/201909300000/>spring cloud config source code analysis</a></li><li class=post-item><a href=/posts/201909180000/>Load balancing</a></li><li class=post-item><a href=/posts/201909180000/>Spring Cloud Ribbon</a></li><li class=post-item><a href=/posts/201909170000/>Spring Cloud Stream</a></li></ul></div></section><section class="aside-widget widget-categories content-padding-large soft-size--large soft-style--box"><h2 class=widget-header><div class=title><span>Categories</span></div></h2><div class=widget-body><ul class=categories-list><li><a href=https://onlw.github.io/categories/program/>program</a>
<span>39</span></li><li><a href=https://onlw.github.io/categories/notes/>notes</a>
<span>4</span></li><li><a href=https://onlw.github.io/categories/default/>default</a>
<span>1</span></li><li><a href=https://onlw.github.io/categories/doc/>doc</a>
<span>1</span></li></ul></div></section><section class="aside-widget widget-tags content-padding-large soft-size--large soft-style--box"><h2 class=widget-header><div class=title><span>Tags</span></div></h2><div class=widget-body><div class=tags-list><a href=https://onlw.github.io/tags/spring-cloud/ data-count=5 class="soft-size--small soft-style--hover soft-style--active">spring-cloud</a>
<a href=https://onlw.github.io/tags/laravel/ data-count=4 class="soft-size--small soft-style--hover soft-style--active">laravel</a>
<a href=https://onlw.github.io/tags/mq/ data-count=3 class="soft-size--small soft-style--hover soft-style--active">MQ</a>
<a href=https://onlw.github.io/tags/hexo/ data-count=2 class="soft-size--small soft-style--hover soft-style--active">hexo</a>
<a href=https://onlw.github.io/tags/java/ data-count=2 class="soft-size--small soft-style--hover soft-style--active">java</a>
<a href=https://onlw.github.io/tags/kafka/ data-count=2 class="soft-size--small soft-style--hover soft-style--active">kafka</a>
<a href=https://onlw.github.io/tags/mysql/ data-count=2 class="soft-size--small soft-style--hover soft-style--active">mysql</a>
<a href=https://onlw.github.io/tags/search-engine/ data-count=2 class="soft-size--small soft-style--hover soft-style--active">search-engine</a>
<a href=https://onlw.github.io/tags/software/ data-count=2 class="soft-size--small soft-style--hover soft-style--active">software</a>
<a href=https://onlw.github.io/tags/api-gateway/ data-count=1 class="soft-size--small soft-style--hover soft-style--active">api-gateway</a>
<a href=https://onlw.github.io/tags/clickhouse/ data-count=1 class="soft-size--small soft-style--hover soft-style--active">clickhouse</a>
<a href=https://onlw.github.io/tags/composer/ data-count=1 class="soft-size--small soft-style--hover soft-style--active">composer</a></div></div><div class=widget-footer><a href=https://onlw.github.io/tags/ class="more-link center">show all<svg class="icon icon-more" width="16" height="16" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M60.928 247.808c-13.824-13.824-36.352-13.824-50.688.0-13.824 13.824-13.824 36.352.0 50.688L224.256 512 10.24 725.504c-13.824 13.824-13.824 36.352.0 50.688 7.168 7.168 15.872 10.24 25.088 10.24s18.432-3.584 25.088-10.24L299.52 537.088c13.824-13.824 13.824-36.352.0-50.688L60.928 247.808zm356.864.0c-13.824-13.824-36.352-13.824-50.688.0-13.824 13.824-13.824 36.352.0 50.688L580.608 512 367.104 725.504c-13.824 13.824-13.824 36.352.0 50.688 7.168 7.168 15.872 10.24 25.088 10.24s18.432-3.584 25.088-10.24l239.104-239.104c13.824-13.824 13.824-36.352.0-50.688L417.792 247.808zM1013.76 486.912 774.656 247.808c-13.824-13.824-36.352-13.824-50.688.0-13.824 13.824-13.824 36.352.0 50.688L937.472 512 723.968 725.504c-13.824 13.824-13.824 36.352.0 50.688 7.168 7.168 15.872 10.24 25.088 10.24s18.432-3.584 25.088-10.24l239.104-239.104c14.336-13.824 14.336-36.352.512-50.176z"/></svg></a></div></section></aside></div></main><footer class="footer-container layout-block"><div class=social-icons><a class="soft-size--primary soft-style--box" href=https://github.com/onlw target=_blank rel="noopener noreferrer"><svg class="icon icon-github" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3.0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4.0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4.0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"/></svg></a><a class="soft-size--primary soft-style--box" href target=_blank rel="noopener noreferrer"><svg class="icon icon-twitter" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M962.285714 233.142857q-38.285714 56-92.571429 95.428571.571429 8 .571429 24 0 74.285714-21.714286 148.285714t-66 142-105.428571 120.285714-147.428571 83.428571-184.571429 31.142857q-154.857143.0-283.428571-82.857143 20 2.285714 44.571429 2.285714 128.571429.0 229.142857-78.857143-60-1.142857-107.428571-36.857143t-65.142857-91.142857q18.857143 2.857143 34.857143 2.857143 24.571429.0 48.571429-6.285714-64-13.142857-106-63.714286t-42-117.428571v-2.285714q38.857143 21.714286 83.428571 23.428571-37.714286-25.142857-60-65.714286t-22.285714-88q0-50.285714 25.142857-93.142857 69.142857 85.142857 168.285714 136.285714t212.285714 56.857143q-4.571429-21.714286-4.571429-42.285714.0-76.571429 54-130.571429t130.571429-54q80 0 134.857143 58.285714 62.285714-12 117.142857-44.571429-21.142857 65.714286-81.142857 101.714286 53.142857-5.714286 106.285714-28.571429z"/></svg></a><a class="soft-size--primary soft-style--box" href target=_blank rel="noopener noreferrer"><svg class="icon icon-instagram" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 0C372.906667.0 355.541333.64 300.928 3.072 246.4 5.632 209.28 14.208 176.64 26.88c-33.664 13.056-62.250667 30.592-90.709333 59.050667S39.893333 142.933333 26.88 176.64C14.208 209.28 5.589333 246.4 3.072 300.928.512 355.541333.0 372.906667.0 512s.64 156.458667 3.072 211.072c2.56 54.485333 11.136 91.648 23.808 124.288a251.093333 251.093333.0 0059.050667 90.709333A250.368 250.368.0 00176.64 997.12c32.682667 12.629333 69.802667 21.290667 124.288 23.808C355.541333 1023.488 372.906667 1024 512 1024s156.458667-.64 211.072-3.072c54.485333-2.56 91.648-11.178667 124.288-23.808a251.648 251.648.0 0090.709333-59.050667A250.026667 250.026667.0 00997.12 847.36c12.629333-32.64 21.290667-69.802667 23.808-124.288 2.56-54.613333 3.072-71.978667 3.072-211.072s-.64-156.458667-3.072-211.072c-2.56-54.485333-11.178667-91.690667-23.808-124.288a251.306667 251.306667.0 00-59.050667-90.709333A249.472 249.472.0 00847.36 26.88C814.72 14.208 777.557333 5.589333 723.072 3.072 668.458667.512 651.093333.0 512 0zm0 92.16c136.661333.0 152.96.682667 206.933333 3.029333 49.92 2.346667 77.013333 10.624 95.018667 17.706667 23.978667 9.258667 40.96 20.352 58.965333 38.229333 17.877333 17.92 28.970667 34.944 38.229334 58.922667 6.997333 18.005333 15.36 45.098667 17.621333 95.018667C931.2 359.082667 931.754667 375.296 931.754667 512s-.64 152.96-3.157334 206.933333c-2.602667 49.92-10.922667 77.013333-17.962666 95.018667a162.56 162.56.0 01-38.357334 58.965333 159.744 159.744.0 01-58.88 38.229334c-17.92 6.997333-45.44 15.36-95.36 17.621333C663.68 931.2 647.68 931.754667 510.72 931.754667c-137.002667.0-153.002667-.64-207.317333-3.157334C253.44 925.994666 225.92 917.674666 208 910.634667a158.549333 158.549333.0 01-58.837333-38.357334 155.477333 155.477333.0 01-38.4-58.88c-7.04-17.92-15.317333-45.44-17.92-95.36-1.92-53.76-2.602667-70.357333-2.602667-206.677333.0-136.362667.682667-153.002667 2.602667-207.402667 2.602667-49.92 10.88-77.397333 17.92-95.317333 8.96-24.32 20.437333-40.96 38.4-58.922667C167.04 131.84 183.722667 120.32 208 111.402667 225.92 104.32 252.842667 96 302.762667 93.44c54.4-1.92 70.4-2.56 207.317333-2.56l1.92 1.28zm0 156.928a262.912 262.912.0 100 525.824 262.912 262.912.0 100-525.824zm0 433.578667c-94.293333.0-170.666667-76.373333-170.666667-170.666667S417.706666 341.333333 512 341.333333 682.666667 417.706666 682.666667 512 606.293334 682.666667 512 682.666667zM846.762667 238.72a61.482667 61.482667.0 01-122.88.0 61.44 61.44.0 01122.88.0z"/></svg></a></div><div class=colour-bar></div><p>© 2021 <a href>kagome</a>.</p><p>Powered by
<a href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a>
Theme -
<a href=https://github.com/miiiku/hugo-theme-kagome target=_blank rel="noopener noreferrer author">kagome</a></p><p><a href=javascript:; id=theme-light>🌞 light</a>
<a href=javascript:; id=theme-dark>🌛 dark</a>
<a href=javascript:; id=theme-auto>🤖️ auto</a></p></footer></body></html>